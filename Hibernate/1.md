1. Question: What is Hibernate and why use it?
   Hint: Explain ORM concept, mapping between Java objects and relational tables, and Hibernate’s advantages (boilerplate elimination, HQL, transaction management, caching).
   Answer: Hibernate is an Object-Relational Mapping (ORM) tool that automatically maps Java classes (entities) to database tables. It eliminates repetitive JDBC boilerplate—opening connections, preparing statements, mapping result sets—by allowing developers to work with Java objects instead of raw SQL. Hibernate provides HQL (Hibernate Query Language) for database-agnostic querying, built-in transaction management, automatic dirty checking, and second-level caching for performance. By handling SQL generation, connection pooling, and object state transitions, Hibernate lets developers focus on business logic rather than low-level database code.

2. Question: How does this mapping happen between the object and database tables?
   Hint: Describe JPA annotations versus XML mapping files; how Hibernate reads annotations like `@Entity`, `@Table`, `@Column` or parses `<class>` and `<property>` entries in `.hbm.xml`.
   Answer: Hibernate can map POJO fields to table columns either via JPA annotations or legacy XML mapping ( `.hbm.xml` ). With annotations, you mark a class with `@Entity` and optionally `@Table(name="…")`. Each field is annotated with `@Column(name="…")`, `@Id`, `@GeneratedValue`, and any association annotations (`@OneToOne`, `@ManyToMany`, etc.). Hibernate scans those annotations at startup and builds metadata for mapping. With XML, you declare `<hibernate-mapping>` containing `<class name="com.example.MyEntity" table="my_table">`, then `<id name="id" column="id"><generator class="identity"/></id>`, and `<property name="fieldName" column="column_name"/>`. During bootstrap, Hibernate reads either the annotated classes or the `*.hbm.xml` files listed in `hibernate.cfg.xml`, constructing a `SessionFactory` that knows how to translate object state to SQL and vice versa.

3. Question: How can Hibernate use JPA annotations?
   Hint: Mention that Hibernate implements the JPA interfaces; JPA defines annotations as “contracts,” and Hibernate provides the actual behavior behind them.
   Answer: JPA (Java Persistence API) defines a set of standardized annotations (e.g., `@Entity`, `@Id`, `@OneToMany`) but does not prescribe implementation. Hibernate implements JPA interfaces under the hood, providing concrete behavior for these annotations. When you annotate your classes with JPA annotations, Hibernate’s metadata parser interprets them, generates SQL, manages entity state, and executes queries accordingly. In essence, JPA defines “what” annotations mean, and Hibernate is a JPA provider that defines “how” to carry out persistence operations based on those annotations.

4. Question: Why Hibernate—why not JDBC?
   Hint: Talk about reducing repetitive JDBC boilerplate (connections, statements, result sets), improved productivity via HQL, built-in transaction management, and caching.
   Answer: JDBC requires manual handling of `Connection`, `PreparedStatement`, `ResultSet`, and manual mapping of rows to objects. Every CRUD operation means writing nearly identical code to open connections, set parameters, handle exceptions and close resources. Hibernate abstracts these duties: it manages connection pooling, generates SQL from entity mappings, tracks dirty state for automatic updates, and offers HQL (database-agnostic queries). It also provides first- and second-level caching, transparent transaction management (via JTA or resource-local transactions), and lazy loading. As a result, Hibernate increases developer productivity, reduces errors, and improves maintainability, whereas JDBC demands repetitive code and tight coupling to vendor-specific SQL.

5. Question: What is boilerplate code?
   Hint: Identify repeated JDBC tasks (opening/closing connections, handling SQL exceptions, mapping `ResultSet` to objects) that Hibernate abstracts away.
   Answer: Boilerplate code refers to repetitive, verbose code patterns that don’t vary much across implementations—such as acquiring a JDBC `Connection`, creating a `PreparedStatement`, setting parameters, executing a query, iterating over a `ResultSet`, mapping columns to object fields, handling SQL exceptions in try-catch blocks, and finally closing connections/resources in `finally` blocks. Hibernate eliminates most boilerplate by managing sessions, generating SQL based on entity mappings, and automatically converting `ResultSet` rows into entity instances.

6. Question: What are the important interfaces used in Hibernate?
   Hint: List `SessionFactory`, `Session`, and `Transaction`, and note their roles (factory for sessions, managing CRUD operations, defining atomic units of work).
   Answer:

    * `SessionFactory`: A thread-safe, heavyweight factory that builds `Session` instances. Typically created once at application startup, per database.
    * `Session`: A lightweight, non-thread-safe object representing a single unit of work or a connection to the database. It provides CRUD methods (`save()`, `update()`, `get()`, etc.), manages first-level cache, and creates `Transaction`.
    * `Transaction`: Represents an atomic unit of work. You begin a transaction with `session.beginTransaction()`, then commit or roll back as needed. It ensures ACID semantics for operations performed within that scope.

7. Question: Why do you use `SessionFactory`?
   Hint: Explain that `SessionFactory` is a thread-safe, heavyweight object created once per database, used to obtain `Session` instances.
   Answer: `SessionFactory` is a thread-safe, immutable object that holds database connection settings, mapping metadata, caching strategy, and other configuration. It is expensive to build (parses mappings, initializes caches), so you create one (or very few) per database at application startup and reuse it. From `SessionFactory`, you obtain `Session` instances (lightweight, non-thread-safe) to perform CRUD operations. Because `SessionFactory` is designed for reuse and shared among threads, it centralizes expensive setup and enforces a consistent configuration across sessions.

8. Question: What is `Session`?
   Hint: Describe `Session` as a lightweight, non-thread-safe object representing a connection—used for CRUD, caching (first-level), and transactions.
   Answer: A `Session` represents a single unit of work with the database. It manages a connection, first-level cache, and entity lifecycle (persistent, detached, transient). You use `Session` to save, update, delete, or fetch entities. Because it caches loaded entities in memory (first-level cache), repeated retrievals of the same entity within the same `Session` return the cached instance. `Session` also creates and manages `Transaction` objects. It is not thread-safe—each thread/transaction must use its own `Session`. At the end of work, you close the `Session` to free its database connection and clear the cache.

9. Question: What is `Transaction`?
   Hint: Point out that `Transaction` represents a unit of work; you begin, commit, or roll back a set of operations as one atomic action.
   Answer: In Hibernate, a `Transaction` encapsulates a series of database operations that should be atomic. You obtain a `Transaction` via `session.beginTransaction()`, perform one or more entity operations (save, update, delete, query), and then call `transaction.commit()` to persist changes or `transaction.rollback()` if something goes wrong. Depending on configuration, `Transaction` may use JDBC transactions (resource-local) or JTA (for distributed transactions). It ensures ACID semantics—either all changes inside that block are applied, or none are.

10. Question: What are the annotations used in Hibernate?
    Hint: Mention `@Entity`, `@Table`, `@Id`, `@GeneratedValue`, `@Column`, `@EmbeddedId`, `@OneToOne`, `@OneToMany`, `@ManyToOne`, `@ManyToMany`, `@Access`, `@PrimaryKeyJoinColumn`, and their basic purposes.
    Answer:

    * `@Entity`: Marks a class as a JPA entity.
    * `@Table(name="…")`: Maps entity to a specific table name (defaults to class name).
    * `@Id`: Marks primary key field or property.
    * `@GeneratedValue(strategy=…)`: Specifies primary key generation strategy—`IDENTITY`, `SEQUENCE`, `TABLE`, or `AUTO`.
    * `@Column(name="…", nullable=…, length=…)`: Maps a field to a column; can override defaults (column name, nullability, length).
    * `@EmbeddedId`: Marks a composite primary key class, requiring a separate `@Embeddable` class.
    * `@OneToOne`, `@OneToMany`, `@ManyToOne`, `@ManyToMany`: Define association mappings between entities.
    * `@JoinColumn(name="…")`: Specifies foreign key column in owner entity for associations.
    * `@JoinTable(name="…", joinColumns=…, inverseJoinColumns=…)`: Defines join table for many-to-many.
    * `@Access(AccessType.FIELD)` or `PROPERTY`: Chooses whether Hibernate uses fields or getters/setters for accessing entity state.
    * `@PrimaryKeyJoinColumn`: Defines a foreign key in a primary key join (used for shared primary key one-to-one).
    * `@Cacheable` and `@Cache(usage=…)`: Enable second-level caching for an entity with a specified concurrency strategy.

11. Question: What is the purpose of `@Entity`?
    Hint: Indicate that `@Entity` marks a class as a persistent JPA entity, instructing Hibernate to manage its mapping to a database table.
    Answer: `@Entity` designates a Java class as a JPA-managed persistence entity. When Hibernate’s `SessionFactory` is built, it scans for classes annotated with `@Entity` and includes them in mapping metadata. This tells Hibernate to create appropriate SQL for create, read, update, and delete operations for instances of that class. Without `@Entity` (or equivalent XML mapping), Hibernate ignores the class.

12. Question: What does `@Table` do?
    Hint: Explain that `@Table(name = "…")` maps an entity class to a specific table name (defaults to class name if omitted).
    Answer: `@Table(name="my_table")` specifies the exact database table to which the entity maps. If omitted, Hibernate defaults to a table name equal to the entity class name (possibly modified by naming strategies). The `@Table` annotation can also specify `schema`, `catalog`, and unique constraints. It’s placed at the class level to control table details.

13. Question: What is `@Access`?
    Hint: Clarify that `@Access(AccessType.FIELD)` or `AccessType.PROPERTY` defines whether Hibernate uses fields or getter/setter methods to read/write data.
    Answer: `@Access` determines how Hibernate reads/writes entity state. `@Access(AccessType.FIELD)` tells Hibernate to bypass getters/setters and use reflection directly on private or package-private fields. `@Access(AccessType.PROPERTY)` instructs Hibernate to call getter/setter methods. This is crucial if you have logic in getters or if field names don’t match attribute names. Per default, Hibernate uses the placement of `@Id` to infer access type: if `@Id` is on a field, field access; if on a getter, property access.

14. Question: What is `@Id`?
    Hint: State that `@Id` marks the primary key field or property of the entity.
    Answer: `@Id` declares which field or getter represents the entity’s primary key. It’s mandatory for each `@Entity`. Combined with `@GeneratedValue` (or other ID annotations), it tells Hibernate how to generate or assign a unique identifier. Without an `@Id`, Hibernate throws a mapping exception because every persistent entity requires a primary key.

15. Question: What is `@EmbeddedId`?
    Hint: Note that `@EmbeddedId` designates a composite primary key class; Hibernate embeds a serializable key class instead of a simple scalar.
    Answer: `@EmbeddedId` indicates that the entity uses a composite primary key represented by a separate `@Embeddable` class. That `@Embeddable` class contains multiple fields which collectively form the primary key. Hibernate persists the fields of the embedded ID into corresponding columns. You use `@EmbeddedId` when your table’s primary key is composed of more than one column, and you want to map it to a single embeddable key class.

16. Question: What is `@Column`?
    Hint: Describe that `@Column(name = "…", nullable = …, length = …)` maps a Java field to a table column and can override defaults.
    Answer: `@Column` customizes the mapping of a field or property to a database column. By default, Hibernate infers a column name from the field or property name. With `@Column(name="col_name", nullable=false, length=50)`, you explicitly specify the database column, nullability, length, precision, or other constraints. If `@Column` is omitted, Hibernate uses defaults (field name as column, `nullable=true`, default length for strings).

17. Question: What is `@GeneratedValue`, and how do you choose a strategy?
    Hint: Explain strategies like `GenerationType.IDENTITY`, `SEQUENCE`, `TABLE`, or `AUTO`, and when to use each based on database support and performance.
    Answer: `@GeneratedValue` indicates that the primary key value is automatically generated. Its `strategy` element can be:

    * `IDENTITY`: The database handles key generation (auto-increment columns). Use when your database supports identity columns.
    * `SEQUENCE`: Hibernate uses a database sequence object (common in Oracle, PostgreSQL). Requires defining a `@SequenceGenerator`.
    * `TABLE`: Hibernate uses a separate table to generate unique IDs (universally supported but slower).
    * `AUTO`: Hibernate chooses the best strategy based on dialect—often maps to `SEQUENCE` on databases that support it, or `TABLE` otherwise.
      Choose based on whether your database supports sequences (prefer `SEQUENCE` for performance), or if identity columns are simpler (use `IDENTITY` if you don’t need pre-insert IDs).

18. Question: How do you map one-to-one, one-to-many, many-to-one, and many-to-many?
    Hint: Summarize each annotation (`@OneToOne`, `@OneToMany`, `@ManyToOne`, `@ManyToMany`), typical `mappedBy` configuration, and join-column setups.
    Answer:

    * `@OneToOne`: Use on two entities when each side has exactly one instance of the other. On the owning side, annotate with `@OneToOne` and `@JoinColumn(name="fk_col")`. On the inverse side, `@OneToOne(mappedBy="owningField")`.
    * `@ManyToOne`: Many child entities map to one parent. Annotate child’s field with `@ManyToOne` and `@JoinColumn(name="parent_id")`. On the parent, optionally use `@OneToMany(mappedBy="parentField")` for bidirectional.
    * `@OneToMany`: One parent has many children. On the parent, use `@OneToMany(mappedBy="parentField", cascade=CascadeType.ALL, fetch=FetchType.LAZY)`.
    * `@ManyToMany`: Many-to-many between two entities. Use `@ManyToMany` on both sides. On one side, define the join table:

      ```java
      @ManyToMany
      @JoinTable(
        name="student_degree",
        joinColumns=@JoinColumn(name="student_id"),
        inverseJoinColumns=@JoinColumn(name="degree_id")
      )
      private Set<Degree> degrees;
      ```

      On the inverse side: `@ManyToMany(mappedBy="degrees")`.

19. Question: What are the types of mappings in Hibernate?
    Hint: List association mappings: one-to-one, one-to-many, many-to-one, and many-to-many, and mention join tables for many-to-many.
    Answer: Hibernate supports the following association mappings:

    * One-to-One: A one-to-one relationship between two entities, mapped via `@OneToOne` and `@JoinColumn`.
    * One-to-Many: A parent entity maps to multiple child entities, using `@OneToMany` (and `mappedBy` on the parent side, with `@ManyToOne` on the child).
    * Many-to-One: Many child entities relate back to one parent, using `@ManyToOne` with `@JoinColumn`.
    * Many-to-Many: Entities have a many-to-many association. Implemented via a join table defined by `@JoinTable`, with two `@JoinColumn` entries. Internally, Hibernate implicitly creates the join table if not provided, or you can specify details manually.

20. Question: How do you code a one-to-one mapping in Hibernate?
    Hint: Show usage of `@OneToOne` with `@JoinColumn`, optional `mappedBy` on the inverse side, and cascade or fetch attributes.
    Answer:

    ```java
    @Entity
    public class Employee {
      @Id
      @GeneratedValue(strategy=GenerationType.IDENTITY)
      private Long id;

      @OneToOne(cascade = CascadeType.ALL, fetch = FetchType.LAZY)
      @JoinColumn(name = "address_id")
      private Address address;
      // getters/setters
    }

    @Entity
    public class Address {
      @Id
      @GeneratedValue(strategy=GenerationType.IDENTITY)
      private Long id;

      @OneToOne(mappedBy = "address", fetch = FetchType.LAZY)
      private Employee employee;
      // getters/setters
    }
    ```

    In this example, `Employee` is the owning side with `@JoinColumn("address_id")`. `Address` uses `mappedBy="address"` to indicate the inverse side. You can specify `cascade` to propagate saves/deletes and `fetch` to control loading strategy.

21. Question: How do you code a many-to-one mapping in Hibernate?
    Hint: Demonstrate `@ManyToOne` on a child entity with `@JoinColumn(name = "parent_id")`; optionally annotate parent with `@OneToMany(mappedBy = "parent")`.
    Answer:

    ```java
    @Entity
    public class Student {
      @Id
      @GeneratedValue(strategy = GenerationType.IDENTITY)
      private Long id;

      @ManyToOne(fetch = FetchType.LAZY)
      @JoinColumn(name = "address_id")
      private Address address;
      // getters/setters
    }

    @Entity
    public class Address {
      @Id
      @GeneratedValue(strategy = GenerationType.IDENTITY)
      private Long id;

      @OneToMany(mappedBy = "address", cascade = CascadeType.ALL)
      private Set<Student> students = new HashSet<>();
      // getters/setters
    }
    ```

    Here, each `Student` has an `address` field annotated with `@ManyToOne` and a `@JoinColumn("address_id")`. The `Address` class has an inverse `@OneToMany(mappedBy="address")` to reference the list of students. You can add cascade types and fetch strategies as needed.

22. Question: How do you code a many-to-many mapping in Hibernate, and what does the join table look like?
    Hint: Describe `@ManyToMany` with `@JoinTable(name = "X_Y", joinColumns = @JoinColumn(name = "x_id"), inverseJoinColumns = @JoinColumn(name = "y_id"))`, and note that Hibernate creates the join table with two foreign keys.
    Answer:

    ```java
    @Entity
    public class Student {
      @Id
      @GeneratedValue(strategy = GenerationType.IDENTITY)
      private Long id;

      @ManyToMany(cascade = CascadeType.ALL, fetch = FetchType.LAZY)
      @JoinTable(
        name = "student_degree",
        joinColumns = @JoinColumn(name = "student_id"),
        inverseJoinColumns = @JoinColumn(name = "degree_id")
      )
      private Set<Degree> degrees = new HashSet<>();
      // getters/setters
    }

    @Entity
    public class Degree {
      @Id
      @GeneratedValue(strategy = GenerationType.IDENTITY)
      private Long id;

      @ManyToMany(mappedBy = "degrees", fetch = FetchType.LAZY)
      private Set<Student> students = new HashSet<>();
      // getters/setters
    }
    ```

    Hibernate will create a join table `student_degree` with two foreign keys: `student_id` referencing `Student(id)` and `degree_id` referencing `Degree(id)`. If not explicitly defined, Hibernate generates a default join table name based on entity names.

23. Question: What is the Hibernate configuration file?
    Hint: Identify `hibernate.cfg.xml` as the XML file holding database connection properties (`driver`, `url`, `username`, `password`, `dialect`) and mapping/resource declarations.
    Answer: The Hibernate configuration file (`hibernate.cfg.xml`) is an XML file placed on the classpath (typically under `src/main/resources`) that contains key settings for Hibernate. Example structure:

    ```xml
    <hibernate-configuration>
      <session-factory>
        <property name="hibernate.dialect">org.hibernate.dialect.PostgreSQLDialect</property>
        <property name="hibernate.connection.driver_class">org.postgresql.Driver</property>
        <property name="hibernate.connection.url">jdbc:postgresql://localhost:5432/mydb</property>
        <property name="hibernate.connection.username">user</property>
        <property name="hibernate.connection.password">pass</property>
        <property name="hibernate.show_sql">true</property>
        <mapping class="com.example.Employee"/>
        <!-- Or mapping resource="com/example/Employee.hbm.xml" -->
      </session-factory>
    </hibernate-configuration>
    ```

    It defines database connectivity, dialect, caching, logging, and lists annotated classes or `.hbm.xml` mapping files. When building `SessionFactory`, Hibernate reads this file to initialize.

24. Question: If you switch from Oracle to SQL Server, do you need a new `SessionFactory`?
    Hint: Explain that a separate `SessionFactory` is needed per distinct database configuration because driver, URL, and dialect change.
    Answer: Yes. `SessionFactory` is configured with a specific `hibernate.dialect`, JDBC driver, URL, username, and password. Switching from Oracle to SQL Server changes the driver class (`oracle.jdbc.OracleDriver` vs `com.microsoft.sqlserver.jdbc.SQLServerDriver`), dialect (`OracleDialect` vs `SQLServerDialect`), URL syntax, and possibly other connection properties. You must rebuild or create a separate `SessionFactory` instance configured for SQL Server. Multiple `SessionFactory` instances can coexist if you work with multiple databases simultaneously.

25. Question: What is the Hibernate mapping file (`.hbm.xml`)?
    Hint: Describe that `.hbm.xml` specifies how a Java class maps to a table—elements `<hibernate-mapping>`, `<class>`, `<id>`, `<property>`, and association elements.
    Answer: A Hibernate mapping file ( `.hbm.xml` ) is an XML descriptor that defines how a Java class and its fields map to a database table and columns. Example:

    ```xml
    <hibernate-mapping>
      <class name="com.example.Employee" table="EMPLOYEE">
        <id name="id" column="EMP_ID">
          <generator class="identity"/>
        </id>
        <property name="firstName" column="FIRST_NAME"/>
        <property name="lastName" column="LAST_NAME"/>
        <many-to-one name="address" column="ADDRESS_ID" class="com.example.Address"/>
        <!-- Other mappings -->
      </class>
    </hibernate-mapping>
    ```

    * `<hibernate-mapping>`: root element.
    * `<class name="…"` with `table="…"`.
    * `<id>`: primary key mapping with `<generator>`.
    * `<property>`: simple field-to-column mapping.
    * `<one-to-one>`, `<many-to-one>`, `<one-to-many>`, `<many-to-many>`: association mappings.
      Hibernate reads this file (listed in `hibernate.cfg.xml`) to construct metadata for persistence.

26. Question: What are the steps to create a sample Hibernate application?
    Hint: Outline: (1) Create POJO class and annotate or map it, (2) Create `.hbm.xml` mapping or use annotations, (3) Create `hibernate.cfg.xml` with DB settings, (4) Build a utility/DAO class to bootstrap `SessionFactory`/`Session` and perform CRUD, (5) Run and verify.
    Answer:

    1. Create the entity class (POJO). For example:

       ```java
       @Entity
       @Table(name="employee")
       public class Employee {
         @Id
         @GeneratedValue(strategy=GenerationType.IDENTITY)
         private Long id;
         private String firstName;
         private String lastName;
         // getters and setters
       }
       ```
    2. Alternatively, create `Employee.hbm.xml` if using XML mapping:

       ```xml
       <hibernate-mapping>
         <class name="com.example.Employee" table="EMPLOYEE">
           <id name="id" column="EMP_ID">
             <generator class="identity"/>
           </id>
           <property name="firstName" column="FIRST_NAME"/>
           <property name="lastName" column="LAST_NAME"/>
         </class>
       </hibernate-mapping>
       ```
    3. Create `hibernate.cfg.xml` in `src/main/resources`:

       ```xml
       <hibernate-configuration>
         <session-factory>
           <property name="hibernate.dialect">org.hibernate.dialect.MySQLDialect</property>
           <property name="hibernate.connection.driver_class">com.mysql.jdbc.Driver</property>
           <property name="hibernate.connection.url">jdbc:mysql://localhost:3306/testdb</property>
           <property name="hibernate.connection.username">root</property>
           <property name="hibernate.connection.password">password</property>
           <property name="hibernate.hbm2ddl.auto">update</property>
           <mapping class="com.example.Employee"/>
         </session-factory>
       </hibernate-configuration>
       ```
    4. Create a utility class to bootstrap Hibernate and perform CRUD:

       ```java
       public class HibernateUtil {
         private static final SessionFactory sessionFactory = buildSessionFactory();

         private static SessionFactory buildSessionFactory() {
           try {
             return new Configuration().configure().buildSessionFactory();
           } catch (Throwable ex) {
             throw new ExceptionInInitializerError(ex);
           }
         }

         public static SessionFactory getSessionFactory() {
           return sessionFactory;
         }

         public static void shutdown() {
           getSessionFactory().close();
         }
       }

       public class EmployeeDAO {
         public void saveEmployee(Employee emp) {
           Session session = HibernateUtil.getSessionFactory().openSession();
           Transaction tx = session.beginTransaction();
           session.save(emp);
           tx.commit();
           session.close();
         }
         // Other CRUD methods
       }
       ```
    5. In your `main` method or test, create an `Employee` object, call `EmployeeDAO.saveEmployee()`, and verify the record is inserted into the database.

27. Question: What is the difference between `openSession()` and `getCurrentSession()`?
    Hint: Note that `openSession()` always returns a new `Session` (manual close required), whereas `getCurrentSession()` returns the existing contextual session bound to the transaction (auto-closed).
    Answer:

    * `SessionFactory.openSession()`: Always creates a new `Session`. The developer must explicitly call `session.close()` when done. Each call yields a distinct, unmanaged `Session`.
    * `SessionFactory.getCurrentSession()`: Returns the “current” session bound to the context (typically the ongoing transaction). You configure this via `hibernate.current_session_context_class` (e.g., `thread` or `jta`). Hibernate automatically closes this session at transaction commit or rollback. If no transaction is active, calling `getCurrentSession()` may throw an exception.
      Use `getCurrentSession()` when you want Hibernate to manage session lifecycle within a transaction, reducing boilerplate. Use `openSession()` for fine-grained control or when you need multiple sessions concurrently without a shared context.

28. Question: What is the difference between `Session.get()` and `Session.load()`?
    Hint: Explain that `get()` hits the database immediately and returns null if not found; `load()` returns a proxy and throws `ObjectNotFoundException` if the entity doesn’t exist when first accessed.
    Answer:

    * `get(Class<T> entityType, Serializable id)`: Immediately hits the database (unless the entity is already in the first-level cache) and returns the fully initialized entity or `null` if no row exists. Suitable when you aren’t sure whether the entity exists.
    * `load(Class<T> entityType, Serializable id)`: Returns a proxy without hitting the database initially. Only when you access a property (beyond the primary key), Hibernate queries the database. If the row doesn’t exist, `load()` throws `org.hibernate.ObjectNotFoundException` at access time. Use `load()` when you’re certain the record exists and want lazy retrieval. Using `load()` reduces an immediate SQL hit and allows chaining with proxies, but be prepared for exceptions if the ID is invalid.

29. Question: What are the types of Hibernate caching?
    Hint: List: First-level (session-scoped, enabled by default), second-level (optional, shared across sessions), and query cache (requires second-level).
    Answer: Hibernate provides three caching levels:

    1. **First-Level Cache**: Session-scoped. Each `Session` instance maintains a cache of persistent entities. Automatically enabled and cannot be disabled. When you retrieve an entity by ID or via a query within the same `Session`, Hibernate serves it from the first-level cache instead of re-executing SQL.
    2. **Second-Level Cache**: Optional, shared across sessions within a `SessionFactory`. Enabled by setting `hibernate.cache.use_second_level_cache=true` and specifying a provider (e.g., EHCache, Infinispan). Entities or collections annotated with `@Cache` are stored in second-level regions. Helps reduce database hits across multiple sessions.
    3. **Query Cache**: Optional cache for query result sets. Requires second-level cache enabled. When a query is annotated or configured to be cacheable, Hibernate stores the result IDs in a query cache region. Subsequent executions of the same query with the same parameters retrieve IDs from query cache, then fetch entities from second-level cache or database.

30. Question: What is first-level cache?
    Hint: Describe that each `Session` maintains its own cache of entities; identical queries within the same session return cached objects.
    Answer: The first-level cache is the in-memory cache associated with a Hibernate `Session`. When you call `session.get()` or run a query, Hibernate stores the resulting entity instance in the session’s cache. Subsequent calls for the same entity ID within that `Session` return the cached object, avoiding additional SQL. The first-level cache ensures identity guarantee—within one `Session`, there’s only one instance of a given entity ID. The cache is cleared when the `Session` is closed or when you call `session.clear()`.

31. Question: Why caching—why not plain JDBC?
    Hint: State that caching reduces repetitive database hits, improving performance by serving frequently accessed entities from memory.
    Answer: With plain JDBC, every query or retrieval results in a database roundtrip. Frequent queries for the same data increase load and latency. Hibernate’s caching (first or second level) stores entities in memory, so repeated access to the same object within a session (first-level) or across sessions (second-level) doesn’t hit the database. This reduces database workload, lowers network overhead, and speeds up read-heavy operations. Additionally, Hibernate’s caching is transparent—developers don’t have to manage caches explicitly when retrieving entities via standard methods.

32. Question: Can you clear the first-level cache?
    Hint: Mention `session.clear()` or `session.evict(entity)` to remove objects from the session cache; without clearing, cached data persists until session close.
    Answer: Yes. You can remove a specific entity from the first-level cache by calling `session.evict(entity)`. This forces Hibernate to reload the entity from the database if accessed again. To clear the entire session cache, use `session.clear()`, which evicts all entities and pending changes (but doesn’t commit or roll back). After calling `clear()`, the session no longer holds any persistence contexts and behaves as if newly opened. Note that clearing the cache mid-transaction may lead to unexpected database hits if you access entities again.

33. Question: Will a cached object in one session be visible to another session?
    Hint: Clarify that first-level cache is session-scoped, so one session’s cached entities are not visible to another.
    Answer: No. First-level cache is strictly scoped to a single `Session`. If Session A caches entity `E`, Session B will not see that cached instance. Session B will either retrieve `E` from the second-level cache (if configured) or query the database. The two sessions maintain independent first-level caches; closing a session evicts its entire cache and makes no change to other sessions.

34. Question: What happens to first-level cache when the session is closed?
    Hint: Explain that closing the session evicts all cached objects—cached data is lost, requiring a new session to repopulate.
    Answer: When you close a `Session`, Hibernate evicts all entities in its first-level cache, freeing memory and closing the underlying JDBC connection. Any unsaved changes are lost if you haven’t committed the transaction first. After closing, the cache vanishes, and a newly opened session starts with an empty cache. Therefore, any cached entities in a closed session no longer exist in memory.

35. Question: What is second-level cache?
    Hint: Describe second-level cache as a shared, optional cache across sessions (enabled via configuration) to store entities/collections after session close.
    Answer: The second-level cache is an optional, process-scoped cache shared by all sessions in a `SessionFactory`. Once enabled (`hibernate.cache.use_second_level_cache=true` and specifying a provider like EHCache), Hibernate can store entity data or collection data in memory (or disk) beyond the lifespan of a single session. When one session loads an entity and writes it to second-level cache, any subsequent session retrieving the same entity ID can fetch it from cache rather than hitting the database. Entities must be annotated (`@Cache`) to use a second-level cache region. This significantly reduces database queries across sessions and improves scalability, especially in read-heavy applications.

36. Question: How do you configure Hibernate second-level cache using EHCache?
    Hint: List steps: (1) Add EHCache dependency/JAR, (2) In `hibernate.cfg.xml`, set `hibernate.cache.region.factory_class` to EHCache’s factory and enable `<property name="hibernate.cache.use_second_level_cache">true</property>`, (3) Reference your `ehcache.xml` via `hibernate.cache.provider_configuration_file_resource_path`, (4) Annotate entities with `@Cache(region = "X", usage = CacheConcurrencyStrategy.READ_WRITE)`.
    Answer:

    1. **Add EHCache dependency**:

       ```xml
       <!-- Maven -->
       <dependency>
         <groupId>org.hibernate</groupId>
         <artifactId>hibernate-ehcache</artifactId>
         <version>${hibernate.version}</version>
       </dependency>
       <dependency>
         <groupId>net.sf.ehcache</groupId>
         <artifactId>ehcache</artifactId>
         <version>${ehcache.version}</version>
       </dependency>
       ```
    2. **Enable second-level cache in `hibernate.cfg.xml`**:

       ```xml
       <property name="hibernate.cache.use_second_level_cache">true</property>
       <property name="hibernate.cache.region.factory_class">org.hibernate.cache.ehcache.EhCacheRegionFactory</property>
       <property name="hibernate.cache.use_query_cache">true</property>
       <property name="hibernate.cache.provider_configuration_file_resource_path">ehcache.xml</property>
       ```
    3. **Create `ehcache.xml`** (in `src/main/resources`):

       ```xml
       <ehcache>
         <diskStore path="java.io.tmpdir/ehcache_disk_store"/>
         <defaultCache
           maxEntriesLocalHeap="10000"
           eternal="false"
           timeToIdleSeconds="120"
           timeToLiveSeconds="120"
           overflowToDisk="true"
           memoryStoreEvictionPolicy="LRU"/>
         <cache name="com.example.Employee"
                maxEntriesLocalHeap="1000"
                timeToLiveSeconds="600"
                memoryStoreEvictionPolicy="LRU"/>
         <!-- Define additional region caches as needed -->
       </ehcache>
       ```
    4. **Annotate entities for caching**:

       ```java
       @Entity
       @Cacheable
       @org.hibernate.annotations.Cache(
         usage = CacheConcurrencyStrategy.READ_WRITE,
         region = "com.example.Employee"
       )
       public class Employee {
         @Id
         @GeneratedValue(strategy = GenerationType.IDENTITY)
         private Long id;
         // fields, getters/setters
       }
       ```
    5. After building and running, Hibernate stores `Employee` entities in the EHCache region `"com.example.Employee"`. Other sessions retrieve cached entities from EHCache rather than hitting the database.

37. Question: What are the four steps to enable EHCache in your project?
    Hint: (1) Include EHCache dependency, (2) Add second-level and query-cache properties in `hibernate.cfg.xml`, (3) Create/configure `ehcache.xml` with cache regions (name, `maxEntries`, `timeToLive`, overflow), (4) Annotate entities with `@Cache` and specify region and strategy.
    Answer:

    1. **Include EHCache JARs**: In your build file (Maven/Gradle), add dependencies for `hibernate-ehcache` and `ehcache`.
    2. **Enable caching in Hibernate config**: In `hibernate.cfg.xml`, set

       ```xml
       <property name="hibernate.cache.use_second_level_cache">true</property>
       <property name="hibernate.cache.region.factory_class">org.hibernate.cache.ehcache.EhCacheRegionFactory</property>
       <property name="hibernate.cache.use_query_cache">true</property>
       <property name="hibernate.cache.provider_configuration_file_resource_path">ehcache.xml</property>
       ```
    3. **Create `ehcache.xml`**: Define cache regions, default cache settings, and disk store. For example:

       ```xml
       <ehcache>
         <diskStore path="java.io.tmpdir/ehcache_disk_store"/>
         <defaultCache
           maxEntriesLocalHeap="1000"
           eternal="false"
           timeToIdleSeconds="300"
           timeToLiveSeconds="600"
           overflowToDisk="true"/>
         <cache name="com.example.Employee"
                maxEntriesLocalHeap="500"
                timeToLiveSeconds="120"
                memoryStoreEvictionPolicy="LRU"/>
       </ehcache>
       ```
    4. **Annotate persistent classes**: Use

       ```java
       @Cacheable
       @org.hibernate.annotations.Cache(
         usage = CacheConcurrencyStrategy.READ_WRITE,
         region = "com.example.Employee"
       )
       ```

       on entity classes or collections you want to cache. Then rebuild and deploy; Hibernate automatically populates EHCache regions.

38. Question: How do you define cache regions in `ehcache.xml`?
    Hint: Show `<cache name="regionName" maxEntriesLocalHeap="…" timeToLiveSeconds="…" memoryStoreEvictionPolicy="LRU"/>`, plus default cache settings and disk store path.
    Answer: In `ehcache.xml`, you define a `<cache>` element per region. Example:

    ```xml
    <ehcache>
      <diskStore path="java.io.tmpdir/ehcache_disk_store"/>
      <defaultCache
        maxEntriesLocalHeap="1000"
        eternal="false"
        timeToIdleSeconds="180"
        timeToLiveSeconds="300"
        memoryStoreEvictionPolicy="LRU"/>
      <cache name="com.example.Employee"
             maxEntriesLocalHeap="500"
             eternal="false"
             timeToLiveSeconds="600"
             overflowToDisk="true"
             memoryStoreEvictionPolicy="LRU"/>
      <cache name="org.hibernate.cache.StandardQueryCache"
             maxEntriesLocalHeap="1000"
             timeToLiveSeconds="3600"
             memoryStoreEvictionPolicy="LRU"/>
      <cache name="org.hibernate.cache.UpdateTimestampsCache"
             maxEntriesLocalHeap="1000"
             timeToLiveSeconds="3600"
             memoryStoreEvictionPolicy="LRU"/>
    </ehcache>
    ```

    * `diskStore path="…"`: Location for on-disk overflow if `overflowToDisk="true"`.
    * `defaultCache`: Default region template.
    * `<cache name="regionName" …>`: Defines a named region (e.g., your entity class, the query cache region). You set `maxEntriesLocalHeap`, `timeToIdleSeconds`, `timeToLiveSeconds`, eviction policy (`LRU`, `LFU`), and `overflowToDisk` if needed.

39. Question: How do you use the `@Cache` annotation to enable caching for an entity?
    Hint: Provide `@Cache(usage = CacheConcurrencyStrategy.READ_WRITE, region = "regionName")` on the entity class so Hibernate knows which region stores its data.
    Answer: On your entity class, annotate as follows:

    ```java
    @Entity
    @Table(name="employee")
    @Cacheable
    @org.hibernate.annotations.Cache(
      usage = CacheConcurrencyStrategy.READ_WRITE,
      region = "com.example.Employee"
    )
    public class Employee {
      @Id
      @GeneratedValue(strategy = GenerationType.IDENTITY)
      private Long id;
      private String firstName;
      private String lastName;
      // getters/setters
    }
    ```

    * `@Cacheable` marks the entity as eligible for second-level caching.
    * `@Cache(usage=CacheConcurrencyStrategy.READ_WRITE, region="…")` specifies concurrency strategy and region name.
      Ensure that `hibernate.cache.use_second_level_cache=true` in `hibernate.cfg.xml` and that `ehcache.xml` (or other provider config) defines the region `"com.example.Employee"`.

40. Question: If you need more high-level Hibernate questions or configuration questions, will you request a second session?
    Hint: Clarify that you’d ask for feedback or a comment to trigger an advanced set of questions, indicating willingness to continue.
    Answer: Typically you’d close by inviting feedback—“If you’d like more advanced questions on Hibernate configuration, performance tuning, or advanced mapping strategies, please let me know in the comments,”—indicating you’re ready to provide a follow-up session once the interviewer or candidate has reviewed the current set. This demonstrates openness to continued dialogue and deeper exploration.

---

If you’d like additional sections (e.g., advanced performance, schema generation, or third-party integration), feel free to request a follow-up!
